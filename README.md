1. Не робив розумні вказівники. Для ігрових об'єктів такої простої гри вирішив, що достатньо робити все через вказівники на інстанси в stack memory. По суті розумні вказівники реалізують `RAII` над `raw pointers`. Я тут це якісно також показав напрклад з `Window`, `Renderer`
 - Створення ігрових об'єктів можна побачити в `pong_scene.cpp`, `pong_scene.h`
 - Тим самим я хотів показати, що знаю оптимізованіший метод використанням move семантики. Як приклад `RHI Wrappers` 
2. Наскільки потрібно показати знання контенйнерів, я тільки використовував `std::vector`. На співбесіді можу розказати про інші.
3. Вроді знання ООП я гарно показав але. Багато нюансів це я знаю. Наприклад
 - pong_scene - створюю вручну об'єкти і додаю в контейнер. Це можна вирішити якимось Factory паттерном, щоб автоматично додавало до контейнеру. Також pong_scene - це приклад створеного нового рівня гри. Тому не просто `Scene`, а `PongScene` показавши що я створив ігровий рівень. Також воно виконує не одну задачу. Створення об'єктів і та їх зберігання і використання в ігровому циклі. Також розділити можна на частини. Але подумав знову ж таки, що це просто ігровий рівень. Мені багато не потрібно для цієї гри.
 - Користувався прикладом Unreal Engine. Тому можна побачити player_controller та paddle посилаються одне на одного і також є `ai_controller`. Можна вважати що `Paddle`, це `APawn`.
 - RHI - по суті я спочатку хотів на OpenGL робити рендеринг, а потім подумав, не хочеться писати бібліотеку RAII для нього, щоб хоча б якось його використовувати, тому зробив на `SDL_Renderer`. І саме тому створився RHI, щоб може в майбутньому я зроблю через OpenGL.
 - Бачив в деяких репозиторіях main.cpp розділяють на ще 4 хедера, котрий оброблюють ініціалізацію, ітерацію і так далі. Не знаю для чого, але основний GameLoop в мене в `AppState`
 - Також я бачив звичайно як Unreal Engine все реалізуює. Дуже подобається. Тому обробку ігрових подій я би також виносив би в якийсь там GameMode, GameState і так далі.
4. Як бачите використовую `.clang-format`, `.clang-tidy`. Хоча насправді `CLion` також непогано форматує. І я взяв ці файли з `SDL3` репозиторію.
5. Які використовуються паттерни проектування.
 - RHI - по суті приклад Facade шаблону
 - Game Loop
 - Можна додати Observer - як частина обробки подій колізій
 - Можна додати Factory - для додавання ігрових об'єктів в контейнер об'єктів
 - Не використовував Singleton, хоча `Pong_utility` можна представити що це і є Singleton. Я їх не дуже полюбляю, бо створює багато залежностей в коді. Я полюбляю `Dependency Injection`. Можете побачити це всюди в моєму коді.
 - Ще для ігор полюбляю `Entity Component System` на основі нього був створенний Dwarf Fortress. Як на мене це самий найоптимізованіший паттерн для створення ігор з багатьма ігровими об'єктами
6. Не додавав таблицю очок. В принципі можу додати за допомогою `SDL_ttf`. Але подумав нащо витрачати час, щоб показати зробленний аналог `RHI`, де малювались би цифри
7. Перевіряв запуск як на Windows, так і на Archlinux. Думав проблем із запуском на Ubuntu не буде, так як CMakeLists дуже якісно все обробляє
думаю<br><br>
P.S. Додадтково можу і хочу розказати на співбесіді, дякую за приділенний час за перевірку тестового завдання